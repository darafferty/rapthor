# Copyright (C) 2020 ASTRON (Netherlands Institute for Radio Astronomy)
# SPDX-License-Identifier: GPL-3.0-or-later

import os
import ctypes
import numpy as np
import idg

FourierDomainToImageDomain = 0
ImageDomainToFourierDomain = 1

class Proxy(object):

    """
    The Proxy class provides access to implementations of IDG.
    It is a wrapper around the  C++ class :cpp:class:`Proxy <idg::proxy::Proxy>`
    A proxy object can be created by instantiating one of the subclasses
    provided in the submodules.

    A proxy can be used for gridding, degridding or calibration.
    The proxy needs to be initialized. The initialization sets the
    mode to either gridding, degridding or calibration.
    To switch to a different mode the proxy needs to be re-initialized.

    Initialization for gridding/degridding is done by consecutive calls
    to :py:meth:`set_grid` and :py:meth:`init_cache`.

    After that a series of either :py:meth:`gridding` or :py:meth:`degridding`
    calls follows. The data needs to be grouped per baseline. The first
    (slowest varying) index is baseline number, the second index is time.
    This is the transpose of how the data us usually ordered in a measurement set.

    The :py:meth:`gridding` method might keep partial results in internal buffers.
    To get the final grid a call to :py:meth:`get_final_grid` is needed.
    """

    def __del__(self):
        """Destroy"""
        self.lib.Proxy_destroy.argtypes = [ ctypes.c_void_p ]
        self.lib.Proxy_destroy(self.obj)

    def gridding(
        self,
        kernel_size,
        frequencies,
        visibilities,
        uvw,
        baselines,
        aterms,
        aterm_offsets,
        taper):
        """
        Grid visibilities onto grid.

        :param kernel_size: int, see :doc:`kernelsize`
        :param frequencies: np.ndarray(
                shapenr_channels,
                dtype = np.float32)
        :param visibilities: np.ndarray(
                shape=(nr_baselines, nr_timesteps, nr_channels, nr_correlations),
                dtype=np.complex64)
        :param uvw: np.ndarray(
                shape=(nr_baselines, nr_timesteps,3),
                dtype = np.float32)
        :param baselines: np.ndarray(
                shape=(nr_baselines,2),
                dtype=np.intc)
        :param aterms: np.ndarray(
                shape=(nr_timeslots, nr_stations, subgrid_size, subgrid_size, 4),
                dtype = np.complex64)
        :param aterm_offsets: np.ndarray(
                shape=(nr_timeslots+1),
                dtype = np.int)
        :param taper: np.ndarray(
                shape=(subgrid_size, subgrid_size),
                dtype = np.float32)

        First a plan is generated by a call to C++ member function :cpp:func:`idg::proxy::Proxy::make_plan`.
        Then C++ member function :cpp:func:`idg::proxy::Proxy::gridding` is called.

        """
        # extract dimensions
        nr_channels = frequencies.shape[0]
        nr_baselines    = visibilities.shape[0]
        nr_timesteps    = visibilities.shape[1]
        nr_correlations = visibilities.shape[3]
        nr_timeslots       = aterms.shape[0]
        nr_stations        = aterms.shape[1]
        subgrid_size       = aterms.shape[2]

        #Set C function signature
        self.lib.Proxy_gridding.argtypes = [
            ctypes.c_void_p, # proxy
            ctypes.c_int,    # kernel_size
            ctypes.c_int,    # subgrid_size
            ctypes.c_int,    # nr_channels
            ctypes.c_int,    # nr_baselines
            ctypes.c_int,    # nr_timesteps,
            ctypes.c_int,    # nr_correlations,
            ctypes.c_int,    # nr_timeslots
            ctypes.c_int,    # int nr_stations
            np.ctypeslib.ndpointer(
                dtype=np.float32,
                shape=(nr_channels,),
                flags='C_CONTIGUOUS'),   # frequencies
            np.ctypeslib.ndpointer(
                dtype=np.complex64,
                shape=(nr_baselines, nr_timesteps, nr_channels, nr_correlations),
                flags='C_CONTIGUOUS'), # visibilities
            np.ctypeslib.ndpointer(
                dtype=np.float32,
                shape=(nr_baselines, nr_timesteps, 3),
                flags='C_CONTIGUOUS'), # uvw
            np.ctypeslib.ndpointer(
                dtype=np.intc,
                shape=(nr_baselines,2),
                flags='C_CONTIGUOUS'),# baselines
            np.ctypeslib.ndpointer(
                dtype=np.complex64,
                shape=(nr_timeslots, nr_stations, subgrid_size, subgrid_size, 4),
                flags='C_CONTIGUOUS'), # aterms
            np.ctypeslib.ndpointer(
                dtype=np.intc,
                shape=(nr_timeslots+1, ),
                flags='C_CONTIGUOUS'), # aterm_offsets
            np.ctypeslib.ndpointer(
                dtype=np.float32,
                shape=(subgrid_size, subgrid_size),
                flags='C_CONTIGUOUS')] # taper
        # call C function to do the work
        self.lib.Proxy_gridding(
            self.obj,
            kernel_size,
            subgrid_size,
            nr_channels,
            nr_baselines,
            nr_timesteps,
            nr_correlations,
            nr_timeslots,
            nr_stations,
            frequencies,
            visibilities,
            uvw,
            baselines,
            aterms,
            aterm_offsets,
            taper)

    def degridding(
        self,
        kernel_size,
        frequencies,
        visibilities,
        uvw,
        baselines,
        aterms,
        aterm_offsets,
        taper):
        """
        Degrid visibilities from grid.

        :param kernel_size: int, see :doc:`kernelsize`
        :param frequencies: np.ndarray(
                shapenr_channels,
                dtype = np.float32)
        :param visibilities: np.ndarray(
                shape=(nr_baselines, nr_timesteps, nr_channels, nr_correlations),
                dtype=np.complex64)
        :param uvw: np.ndarray(
                shape=(nr_baselines, nr_timesteps, 3),
                dtype = np.float32)
        :param baselines: np.ndarray(
                shape=(nr_baselines, 2),
                dtype=np.intc)
        :param aterms: np.ndarray(
                shape=(nr_timeslots, nr_stations, subgrid_size, subgrid_size, 4),
                dtype = np.complex64)
        :param aterm_offsets: np.ndarray(
                shape=(nr_timeslots+1),
                dtype = np.intc)
        :param taper: np.ndarray(
                shape=(subgrid_size, subgrid_size),
                dtype = np.float32)

        First a plan is generated by a call to C++ member function :cpp:func:`idg::proxy::Proxy::make_plan`.
        Then C++ member function :cpp:func:`idg::proxy::Proxy::degridding` is called.
        """
        # extract dimensions
        nr_channels = frequencies.shape[0]
        nr_baselines    = visibilities.shape[0]
        nr_timesteps    = visibilities.shape[1]
        nr_correlations = visibilities.shape[3]
        nr_timeslots       = aterms.shape[0]
        nr_stations        = aterms.shape[1]
        subgrid_size       = aterms.shape[2]

        # Set C function signature
        self.lib.Proxy_degridding.argtypes = [
            ctypes.c_void_p, # proxy
            ctypes.c_int,    # kernel_size
            ctypes.c_int,    # subgrid_size
            ctypes.c_int,    # nr_channels
            ctypes.c_int,    # nr_baselines
            ctypes.c_int,    # nr_timesteps,
            ctypes.c_int,    # nr_correlations,
            ctypes.c_int,    # nr_timeslots
            ctypes.c_int,    # int nr_stations
            np.ctypeslib.ndpointer(
                dtype=np.float32,
                shape=(nr_channels,),
                flags='C_CONTIGUOUS'),   # frequencies
            np.ctypeslib.ndpointer(
                dtype=np.complex64,
                shape=(nr_baselines, nr_timesteps, nr_channels, nr_correlations),
                flags='C_CONTIGUOUS'), # visibilities
            np.ctypeslib.ndpointer(
                dtype=np.float32,
                shape=(nr_baselines, nr_timesteps,3),
                flags='C_CONTIGUOUS'), # uvw
            np.ctypeslib.ndpointer(
                dtype=np.intc,
                shape=(nr_baselines, 2),
                flags='C_CONTIGUOUS'),# baselines
            np.ctypeslib.ndpointer(
                dtype=np.complex64,
                shape=(nr_timeslots, nr_stations, subgrid_size, subgrid_size, 4),
                flags='C_CONTIGUOUS'), # aterms
            np.ctypeslib.ndpointer(
                dtype=np.intc,
                shape=(nr_timeslots+1, ),
                flags='C_CONTIGUOUS'), # aterm_offsets
            np.ctypeslib.ndpointer(
                dtype=np.float32,
                shape=(subgrid_size, subgrid_size),
                flags='C_CONTIGUOUS')] # taper
        # call C function to do the work
        self.lib.Proxy_degridding(
            self.obj,
            kernel_size,
            subgrid_size,
            nr_channels,
            nr_baselines,
            nr_timesteps,
            nr_correlations,
            nr_timeslots,
            nr_stations,
            frequencies,
            visibilities,
            uvw,
            baselines,
            aterms,
            aterm_offsets,
            taper)

    def init_cache(self, subgrid_size, cell_size, w_step, shift):
        """
        :param subgrid_size: int, size of the subgrids in pixels in one dimension
        :param cell_size: float, size of a pixel in radians
        :param w_step: float, distance in wavelengths between layers in w-stacking/w-tiling
        :param shift: np.ndarray(
                shape=(2, ),
                dtype = np.float32), l,m pointing offset (facet position) in radians

        This call is forwarded to C++ member function :cpp:func:`idg::proxy::Proxy::init_cache`.
        """
        self.lib.Proxy_init_cache.argtypes = [
            ctypes.c_void_p,             #Proxy* p,
            ctypes.c_uint,               #unsigned int subgrid_size,
            ctypes.c_float,              #const float cell_size,
            ctypes.c_float,              #float w_step,
            np.ctypeslib.ndpointer(
                dtype=np.float32,
                shape=(2,),
                flags='C_CONTIGUOUS')]   #float* shift,
        self.lib.Proxy_init_cache(
            self.obj,
            subgrid_size,
            cell_size,
            w_step,
            shift)

    def calibrate_init(
        self,
        kernel_size,
        frequencies,
        visibilities,
        weights,
        uvw,
        baselines,
        aterm_offsets,
        taper):
        """
        Initialize calibration.

        :param kernel_size: int, see :doc:`kernelsize`
        :param frequencies: np.ndarray(
                shape = (nr_channel_blocks, nr_channels)
                dtype = np.float32)
        :param visibilities: np.ndarray(
                shape=(nr_baselines, nr_timesteps, nr_channels, nr_correlations),
                dtype=np.complex64)
        :param uvw: np.ndarray(
                shape=(nr_baselines, nr_timesteps, 3),
                dtype = np.float32)
        :param baselines: np.ndarray(
                shape=(nr_baselines, 2),
                dtype=np.intc)
        :param grid: np.ndarray(
                shape=(nr_correlations, subgrid_size, subgrid_size),
                dtype = np.complex64)
        :param taper: np.ndarray(
                shape=(subgrid_size, subgrid_size),
                dtype = np.float32)

        This call is forwarded to C++ member function :cpp:func:`idg::proxy::Proxy::calibrate_init`.
        """
        # extract dimensions
        subgrid_size    = taper.shape[0]
        nr_channel_blocks     = frequencies.shape[0]
        nr_channels_per_block = frequencies.shape[1]
        nr_channels = frequencies.size
        nr_baselines    = visibilities.shape[0]
        nr_timesteps    = visibilities.shape[1]
        nr_correlations = visibilities.shape[3]
        nr_timeslots    = aterm_offsets.shape[0] - 1

        # call C function to do the work

        self.lib.Proxy_calibrate_init.argtypes = [
            ctypes.c_void_p,             #Proxy* p,
            ctypes.c_uint,               #unsigned int kernel_size,
            ctypes.c_uint,               #unsigned int subgrid_size,
            ctypes.c_uint,               #unsigned int nr_channel_blocks,
            ctypes.c_uint,               #unsigned int nr_channels_per_block,
            ctypes.c_uint,               #unsigned int nr_baselines,
            ctypes.c_uint,               #unsigned int nr_timesteps,
            ctypes.c_uint,               #unsigned int nr_timeslots,
            np.ctypeslib.ndpointer(
                dtype=np.float32,
                shape=(nr_channel_blocks, nr_channels_per_block),
                flags='C_CONTIGUOUS'),   #float* frequencies,
            np.ctypeslib.ndpointer(
                dtype=np.complex64,
                shape=(nr_baselines, nr_timesteps, nr_channels, nr_correlations),
                flags='C_CONTIGUOUS'),   #std::complex<float>* visibilities,
            np.ctypeslib.ndpointer(
                dtype=np.float32,
                shape=(nr_baselines, nr_timesteps, nr_channels, nr_correlations),
                flags='C_CONTIGUOUS'),   #float* weights,
            np.ctypeslib.ndpointer(
                dtype = np.float32,
                shape=(nr_baselines, nr_timesteps, 3),
                flags='C_CONTIGUOUS'),   #float* uvw,
            np.ctypeslib.ndpointer(
                dtype=np.intc,
                shape=(nr_baselines, 2),
                flags='C_CONTIGUOUS'),   #unsigned int* baselines,
            np.ctypeslib.ndpointer(
                dtype=np.int32,
                ndim=1,
                shape=(nr_timeslots+1, ),
                flags='C_CONTIGUOUS'),    # aterm_offsets
            np.ctypeslib.ndpointer(
                dtype=np.float32,
                ndim=2,
                shape=(subgrid_size, subgrid_size),
                flags='C_CONTIGUOUS')    # taper
            ]

        self.lib.Proxy_calibrate_init(
            self.obj,
            kernel_size,
            subgrid_size,
            nr_channel_blocks,
            nr_channels_per_block,
            nr_baselines,
            nr_timesteps,
            nr_timeslots,
            frequencies,
            visibilities,
            weights,
            uvw,
            baselines,
            aterm_offsets,
            taper)

    def calibrate_update(self, antenna_nr, aterms, aterm_derivatives, hessian, gradient, residual):
        """
        Compute a hessian, gradient and residual per time slot 
        for a given antenna, aterms and aterm_derivatives

        :param antenna_nr: int
        :param aterms: np.ndarray(
                shape=(nr_channel_blocks, nr_timeslots, nr_stations, subgrid_size, subgrid_size, 4),
                dtype = np.complex64)
        :param aterm_derivatives: np.ndarray(
                shape=(nr_channel_blocks, nr_timeslots, nr_terms, subgrid_size, subgrid_size, 4),
                dtype = np.complex64)
        :param hessian: np.ndarray(
                shape=shape=(nr_channel_blocks, nr_timeslots, nr_terms, nr_terms),
                dtype = np.float64)
        :param gradient: np.ndarray(
                shape=shape=(nr_channel_blocks, nr_timeslots, nr_terms),,
                dtype = np.float64)
        :param residual: np.ndarray(
                shape=shape=(nr_channel_blocks, ),
                dtype = np.float64)

        Update step for calibration. Computes Hessian, gradient and residual for the current working point.
        This call is forwarded to C++ member function :cpp:func:`idg::proxy::Proxy::calibrate_update`.
        """
        nr_channel_blocks = aterms.shape[0]
        nr_timeslots = aterms.shape[1]
        nr_antennas = aterms.shape[2]
        subgrid_size = aterms.shape[3]
        nr_terms = gradient.shape[2]
        nr_correlations = 4

        self.lib.Proxy_calibrate_update.argtypes = [
            ctypes.c_void_p,             #Proxy* p,
            ctypes.c_uint,               #unsigned int antenna_nr
            ctypes.c_uint,               #unsigned int nr_channel_blocks
            ctypes.c_uint,               #unsigned int subgrid_size
            ctypes.c_uint,               #unsigned int nr_antennas
            ctypes.c_uint,               #unsigned int nr_timeslots
            ctypes.c_uint,               #unsigned int nr_terms
            np.ctypeslib.ndpointer(
                dtype=np.complex64,
                shape=(nr_channel_blocks, nr_timeslots, nr_antennas, subgrid_size, subgrid_size, nr_correlations),
                flags='C_CONTIGUOUS'),   #std::complex<float>* aterms
            np.ctypeslib.ndpointer(
                dtype=np.complex64,
                shape=(nr_channel_blocks, nr_timeslots, nr_terms, subgrid_size, subgrid_size, nr_correlations),
                flags='C_CONTIGUOUS'),   #std::complex<float>* aterm_derivatives
            np.ctypeslib.ndpointer(
                dtype=np.float64,
                shape=(nr_channel_blocks, nr_timeslots, nr_terms, nr_terms),
                flags='C_CONTIGUOUS'),   #double* hessian
            np.ctypeslib.ndpointer(
                dtype=np.float64,
                shape=(nr_channel_blocks, nr_timeslots, nr_terms),
                flags='C_CONTIGUOUS'),   #double* gradient
            np.ctypeslib.ndpointer(
                dtype=np.float64,
                shape=(nr_channel_blocks, ),
                flags='C_CONTIGUOUS'),   #double* residual
            ]

        self.lib.Proxy_calibrate_update(
            self.obj,
            antenna_nr,
            nr_channel_blocks,
            subgrid_size,
            nr_antennas,
            nr_timeslots,
            nr_terms,
            aterms,
            aterm_derivatives,
            hessian,
            gradient,
            residual)

    def calibrate_finish(self):
        """
        Finish calibration, freeing internal buffers

        This call is forwarded to C++ member function :cpp:func:`idg::proxy::Proxy::calibrate_finish`.
        """

        self.lib.Proxy_calibrate_finish.argtypes = [
            ctypes.c_void_p,             #Proxy* p,
            ]

        self.lib.Proxy_calibrate_finish(
            self.obj)

    def transform(
        self,
        direction):
        """
        Transform Fourier Domain<->Image Domain.

        :param direction: idg.FourierDomainToImageDomain or idg.ImageDomainToFourierDomain

        This call is forwarded to C++ member function :cpp:func:`idg::proxy::Proxy::transform`.
        """

        # call C function to do the work
        self.lib.Proxy_transform.argtypes = [
                ctypes.c_void_p,
                ctypes.c_int]
        self.lib.Proxy_transform(
            ctypes.c_void_p(self.obj),
            ctypes.c_int(direction))

    def allocate_grid(
        self,
        nr_correlations,
        grid_size):

        # Get pointer to grid data
        self.lib.Proxy_allocate_grid.restype = ctypes.c_void_p
        self.lib.Proxy_allocate_grid.argtypes = [
            ctypes.c_void_p,
            ctypes.c_int,
            ctypes.c_int]
        ptr = self.lib.Proxy_allocate_grid(
            ctypes.c_void_p(self.obj),
            ctypes.c_int(nr_correlations),
            ctypes.c_int(grid_size))

        # Get float pointer to grid data
        ptr = ctypes.cast(ptr, ctypes.POINTER(ctypes.c_float))

        # Construct np array out of this pointer
        shape = (nr_correlations, grid_size, grid_size)
        length = np.prod(shape[:])*2
        grid = np.ctypeslib.as_array(ptr, shape=(length,)).view(np.complex64)
        grid = grid.reshape(shape)

        # Return grid
        return grid

    def set_grid(
        self,
        grid):

        """
        Set grid to use in proxy

        :param grid: np.ndarray(
                shape=(nr_correlations, grid_size, grid_size),
                dtype = np.complex64)
        
        The call is forwarded to C++ member function :cpp:func:`idg::proxy::Proxy::set_grid`
        """

        # Get dimensions
        shape = grid.shape
        nr_w_layers = 1
        nr_correlations = shape[0]
        grid_size = shape[1]
        height = grid_size
        width = grid_size

        # Set argument types
        self.lib.Proxy_set_grid.argtypes = [
                ctypes.c_void_p,
                ctypes.c_void_p,
                ctypes.c_int,
                ctypes.c_int,
                ctypes.c_int,
                ctypes.c_int]

        # Call the C function
        self.lib.Proxy_set_grid(
            ctypes.c_void_p(self.obj),
            grid.ctypes.data,
            ctypes.c_int(nr_w_layers),
            ctypes.c_int(nr_correlations),
            ctypes.c_int(height),
            ctypes.c_int(width))

    def get_final_grid(
        self,
        grid = None):

        """
        Flush all pending gridding operations to grid

        :param grid: np.ndarray(
                shape=(nr_correlations, grid_size, grid_size),
                dtype = np.complex64) Optional, if present data will be copied into this array

        The call is forwarded to C++ member function :cpp:func:`idg::proxy::Proxy::get_final_grid`
        """

        # Set argument types
        self.lib.Proxy_get_final_grid.argtypes = [
                ctypes.c_void_p,
                ctypes.c_void_p,
                ctypes.c_int,
                ctypes.c_int,
                ctypes.c_int,
                ctypes.c_int]

        if grid is not None:

            # Get dimensions
            shape = grid.shape
            nr_w_layers = 1
            nr_correlations = shape[0]
            grid_size = shape[1]
            height = grid_size
            width = grid_size

            # Call the C function
            self.lib.Proxy_get_final_grid(
                ctypes.c_void_p(self.obj),
                grid.ctypes.data,
                ctypes.c_int(nr_w_layers),
                ctypes.c_int(nr_correlations),
                ctypes.c_int(height),
                ctypes.c_int(width))
        else:
            self.lib.Proxy_get_final_grid(
                ctypes.c_void_p(self.obj),
                0,
                0,
                0,
                0,
                0)
