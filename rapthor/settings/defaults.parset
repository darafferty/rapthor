### This file contains the default settings for the Rapthor pipeline ###

[global]
# Full path to working dir where rapthor will run (required). All output will be
# placed in this directory
dir_working = None

# Full path to input MS files (required). Wildcards can be used (e.g.,
# /path/to/data/*.ms) or a list can be given
input_ms = None

# Automatically download a target sky model (default = True). This will have no
# effect if input_sky model is specified. The radius out to which a sky model
# should be downloaded (default is 5 degrees) and the service from which a sky
# model should be downloaded (default is TGSS) can be specified, as can the
# option to overwrite an existing sky model with the downloaded one.
download_initial_skymodel = True
download_initial_skymodel_radius = 5.0
download_initial_skymodel_server = TGSS
download_overwrite_skymodel = False

# Full path to the input sky model file, with true-sky fluxes (required when not
# automatically downloading). If you also have a sky model with apparent flux
# densities, specify it with the apparent_skymodel option (note that the source
# names must be identical in both sky models)
input_skymodel = None
apparent_skymodel = None

# Regroup the input or downloaded sky model as needed to meet target flux
# (default = True). If False, the existing patches are used for the calibration
regroup_input_skymodel = True

# Processing strategy to use (default = selfcal):
# - selfcal: standard self calibration
# - image: image using the input solutions and sky model (no calibration
#   is done)
# - user-supplied file: full path to Python file defining custom strategy
strategy = selfcal

# Fraction of data to process (default = 0.2 for self calibration and 1.0 for
# the final pass). If less than one, the input data are divided by time into
# chunks (of no less than slow_timestep_separate_sec below) that sum to the
# requested fraction, spaced out evenly over the full time range. A final
# fraction can also be specified (default = selfcal_data_fraction) such that a
# final processing pass (i.e., after selfcal finishes) is done with a different
# fraction
selfcal_data_fraction = 0.2
final_data_fraction = 1.0

# Flagging ranges (default = no flagging). A range of times, baselines, and
# frequencies to flag can be specified (see the DPPP documentation for details
# of the syntax). By default, the ranges are AND-ed to produce the final flags,
# but a set expression can be specified that controls how the selections are
# combined. Examples:
# flag_abstime = [12-Mar-2010/11:31:00.0..12-Mar-2010/11:50:00.0]
# flag_baseline = [CS013HBA*]
# flag_freqrange = [125.2..126.4MHz]
# flag_expr = flag_abstime and flag_baseline and flag_freqrange
flag_abstime = None
flag_baseline = None
flag_freqrange = None
flag_expr =

# Full path to an H5parm file with direction-dependent solutions (default =
# None). This file is required if no calibration is to be done. Full-Jones
# solutions can also be supplied. Note: the directions in the H5parm file must
# match the patches in the input sky model, and the time and frequency coverage
# of the solutions must be sufficient to cover the duration and bandwidth of
# the input dataset
input_h5parm = None
input_fulljones_h5parm = None

# Full path to an text file (in ds9 format) that defines the facet layout
# (default = None). If a facet file is supplied, calibration patches and imaging
# facets will be set to those specified in the file, if possible, and the calibrator
# selection parameters specified in the strategy (e.g., target_flux) will be
# ignored (and therefore the patch and facet layout will be held constant
# between cycles)
facet_layout = None


[calibration]
# If one of the included sky models (see rapthor/skymodels) is within 2 *
# PB_FWHM of the field center, include it in the calibration (default = False)
use_included_skymodels = False

# Maximum factor by which the direction-dependent solution intervals can be increased,
# so that fainter calibrators get longer intervals (in the fast and slow solves only;
# default = 1 = disabled)
dd_interval_factor = 1

# General solver parameters
llssolver = qr
maxiter = 150
propagatesolutions = True
solveralgorithm = hybrid
onebeamperpatch = False
stepsize = 0.02
stepsigma = 0.1
tolerance = 5e-3
parallelbaselines = False
sagecalpredict = False

# Fast solve parameters. Note that the solution intervals are set in the strategy
fast_freqstep_hz = 1e6
fast_smoothnessconstraint = 3e6
fast_smoothnessreffrequency = None
fast_smoothnessrefdistance = 0.0

# Slow solve parameters. Note that the solution intervals are set in the strategy
slow_freqstep_hz = 1e6
slow_smoothnessconstraint_joint = 3e6
slow_smoothnessconstraint_separate = 3e6

# Full-Jones solve parameters
fulljones_timestep_sec = 600.0
fulljones_freqstep_hz = 1e6
fulljones_smoothnessconstraint = 0

# Parameters for the LBFGS solver
solverlbfgs_dof = 200.0
solverlbfgs_iter = 4
solverlbfgs_minibatches = 1


[imaging]
# Imaging parameters: pixel size in arcsec (default = 1.25, suitable for HBA
# data), Briggs robust parameter (default = -0.5), min and max uv distance in
# lambda (default = 0, none), taper in arcsec (default = none), and whether
# multiscale clean should be used (default = True)
cellsize_arcsec = 1.25
robust = -0.5
min_uv_lambda = 0.0
max_uv_lambda = 1e6
taper_arcsec = 0.0
do_multiscale_clean = True

# Method to use to correct for direction-dependent effects during imaging:
# "none", "facets", or "screens" (default = facets). If "none", the solutions
# closest to the image centers will be used. If "facets", Voronoi faceting is
# used. If "screens", smooth 2-D screens are used; the type of screen to use can
# be specified with screen_type: "tessellated" (simple, smoothed tessellated
# screens) or "kl" (Karhunen-Lo`eve screens) (default = kl)
dde_method = facets
screen_type = kl

# Save visibilities used for imaging (default = False). If True, the imaging MS
# files will be saved, with the the direction-independent full-Jones solutions,
# if available, applied. Note, however, that the direction-dependent solutions
# will not be applied unless dde_method = "none", in which case the solutions
# closest to the image centers are used
save_visibilities = False

# IDG (image domain gridder) mode to use in WSClean (default = cpu). The mode
# can be "cpu" or "hybrid". Note that IDG is only used when dde_method = "none"
# or "screens"
idg_mode = cpu

# Maximum memory in GB (per node) to use for WSClean jobs (default = 0 = 100%)
mem_gb = 0

# Apply separate XX and YY corrections during facet-based imaging (default =
# True). If False, scalar solutions (the average of the XX and YY solutions)
# are applied instead. (Separate XX and YY corrections are always applied when
# using non-facet-based imaging methods.)
apply_diagonal_solutions = True

# The number of direction-dependent PSFs which should be fit horizontally and
# vertically in the image (default = [1, 1] = direction-independent PSF).
dd_psf_grid = [1, 1]

# Make Stokes QUV images in addition to the Stokes I image (default = False).
# If True, QUV images are made during the final imaging step, once self
# calibration has been completed. The method used to combine the polarizations
# during deconvolution can also be specified. This method can be "link" to use
# linked polarization cleaning or "join" to use joined polarization cleaning
# (default = link)
make_quv_images = False
pol_combine_method = link

# Use MPI to distribute WSClean jobs over multiple nodes (default = False)? If
# True and more than one node can be allocated to each WSClean job (i.e.,
# max_nodes / num_images >= 2), then distributed imaging will be used (only
# available if batch_system = slurm). Note that if MPI is activated, dir_local
# (under the [cluster] section below) must not be set unless it is on a shared
# filesystem
use_mpi = False

# Reweight the visibility data before imaging (default = False)
reweight = False

# Size of area to image when using a grid (default = 1.7 * mean FWHM of the
# primary beam). Number of sectors along RA to use in imaging grid (default =
# 0). The number of sectors in Dec will be determined automatically to ensure
# the whole area specified with grid_center_ra, grid_center_dec,
# grid_width_ra_deg, and grid_width_dec_deg is imaged. Set grid_nsectors_ra = 0
# to force a single sector for the full area. A grid of sectors can be useful
# for computers with limited memory but generally will give inferior results
# compared to an equivalent single sector. Examples:
# grid_width_ra_deg = 5.0
# grid_width_dec_deg = 7.0
# grid_center_ra = 14h41m01.884
# grid_center_dec = +35d30m31.52
# grid_nsectors_ra = 3
grid_width_ra_deg = None
grid_width_dec_deg = None
grid_center_ra = None
grid_center_dec = None
grid_nsectors_ra = 0

# Instead of a grid, imaging sectors can be defined individually by specifying
# their centers and widths. If sectors are specified in this way, they will be
# used instead of the sector grid. Note that the sectors should not overlap.
# Examples:
# sector_center_ra_list = [14h41m01.884, 14h13m23.234]
# sector_center_dec_list = [+35d30m31.52, +37d21m56.86]
# sector_width_ra_deg_list = [0.532, 0.127]
# sector_width_dec_deg_list = [0.532, 0.127]
sector_center_ra_list = []
sector_center_dec_list = []
sector_width_ra_deg_list = []
sector_width_dec_deg_list = []

# Max desired peak flux density reduction at center of the image edges due to
# bandwidth smearing (at the mean frequency) and time smearing (default = 0.15 =
# 15% reduction in peak flux). Higher values can result in shorter run times but
# more smearing away from the sector centers
max_peak_smearing = 0.15

# Skip corner sectors defined by the imaging grid? If True and a grid is used
# (defined by the grid_* parameters above), the four corner sectors are not
# processed (if possible for the given grid)
skip_corner_sectors = False


[cluster]
# Cluster batch system (default = single_machine). Use batch_system = slurm to
# use a SLURM-based cluster
batch_system = single_machine

# For batch_system = slurm, the maximum number of nodes of the cluster to use at
# once can be specified with the max_nodes option (default = 12), the number of
# processors and amount of memory per node to request from SLURM can be
# specified with the cpus_per_task (default = 0 = all) and mem_per_node_gb
# options (default = 0 = all). By setting the cpus_per_task value to the number
# of processors per node, one can ensure that each task gets the entire node to
# itself, which is the recommended way of running Rapthor
max_nodes = 0
cpus_per_task = 0
mem_per_node_gb = 0

# Maximum number of cores and threads per task to use on each node (default = 0
# = all)
max_cores = 0
max_threads = 0

# Number of threads to use by WSClean during deconvolution and parallel gridding
# (default = 0 = 2/5 of max_threads). Higher values will speed up imaging at the
# expense of higher memory usage
deconvolution_threads = 0
parallel_gridding_threads = 0

# Full path to a local disk on the nodes for IO-intensive processing (default =
# not used). The path must exist on all nodes (but does not have to be on a
# shared filesystem). This parameter is useful if you have a fast local disk
# (e.g., an SSD) that is not the one used for dir_working. If this parameter is
# not set, IO-intensive processing (e.g., WSClean) will use a default path in
# dir_working instead. This parameter should not be set in the following
# situations:
#   - when batch_system = single_machine and multiple imaging sectors are
#     used (as each sector will overwrite files from the other sectors)
#   - when use_mpi = True under the [imaging] section above and dir_local is
#     not on a shared filesystem
dir_local = None

# Run the workflows inside a container (default = False)? If True, the CWL
# workflow for each operation (such as calibrate or image) will be run inside a
# container. The type of container can also be specified (one of docker,
# udocker, or singularity; default = docker)
use_container = False
container_type = docker

# CWL runner to use. Currently supported runners are: cwltool and toil (default)
cwl_runner = toil

# Set Toil's coordination directory (only used when Toil is used as the CWL
# runner; default = selected automatically by Toil). Note that this directory
# must be on a 100% POSIX-compatible file system, because Toil heavily depends
# on POSIX file locking to work reliably. For many shared file systems, this
# criterion is not met
dir_coordination = None

# Debug workflow related issues. Enabling this will require significantly more
# disk space. Additionally, when Toil is the CWL runner, some tasks will run on
# a single thread to make debugging easier. The working directory will never be
# cleaned up, stdout and stderr will not be redirectied, and log level of the
# CWL runner will be set to DEBUG.
debug_workflow = False
